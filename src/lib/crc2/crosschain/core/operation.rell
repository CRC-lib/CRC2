// @extend(ft4.auth.auth_handler)
// function () = ft4.auth.add_auth_handler(
//         scope = "crosschain.complete_transfer",
//         flags = ["T"]
//     );

// operation complete_transfer(
//     transfer_tx: gtx_transaction
// ) {
//     val owner = ft4.auth.authenticate();

//     // require proof
//     iccf.require_valid_proof(
//         transfer_tx,
//         require_anchored_proof = true,
//         verify_signers = false
//     );
//     var op = require(
//         transfer_tx
//         .body
//             .operations @? {
//                 .name == "crosschain.transfer" or 
//             .name == "crosschain.transfer_proxy"
//             },
//         "No transfer operation found"
//     );

//     val transfer_details = get_transfer_details(transfer_tx, op);
//     val prev_brid = transfer_tx.body.blockchain_rid;

//     require(
//         not exists(completed_transfers @? { transfer_details.tx_rid }),
//         "Transaction <%s> transfer has already been applied on this chain."
//             .format(transfer_details.tx_rid)
//     );

//     require(owner.id == transfer_details.args.receiver_id, "Caller must be receiver of transfer");
//     require(transfer_details.args.target_brid == chain_context.blockchain_rid, "Current chain is not target chain");
//     require(
//         transfer_details
//             .args
//             .origin_brid == prev_brid or transfer_details
//             .args
//             .origin_brid == chain_context
//             .blockchain_rid,
//         "Transfer can only be proxied through origin chain"
//     );

//     val _token = tokens.token @? { transfer_details.args.origin_brid, transfer_details.args.id };
//     if (exists(_token)) {
//         // unlock token
//         transfers._transfer(get_locked_account(), owner, _token);
//     } else {
//         // clone token
//         require(transfer_details.args.origin_brid != chain_context.blockchain_rid, "token must exist on origin chain");
//         create token.token ( id = transfer_details.args.id, owner, prev_brid );
//     }
//     create completed_transfers ( transfer_details.tx_rid );
// }

// @extend(ft4.auth.auth_handler)
// function () = ft4.auth.add_auth_handler(
//         scope = "crosschain.transfer",
//         flags = ["T"]
//     );

// operation transfer(
//     origin_brid: byte_array,
//     id: integer,
//     target_brid: byte_array,
//     receiver_id: byte_array
// ) {
//     val owner = ft4.auth.authenticate();
//     val _token = require(token.token @? { origin_brid, id }, "token not found '%s'".format(id));
//     require(_token.owner == owner, "token not owned by sender");
//     require(target_brid != chain_context.blockchain_rid, "Transfer must be crosschain");
//     require(origin_brid == _token.origin_brid, "Incorrect origin brid");

//     // lock token
//     if (is_origin_chain(_token)) create locked ( _token, target_brid );
//     token._transfer(_token.owner, get_locked_account(), _token);
// }

// @extend(ft4.auth.auth_handler)
// function () = ft4.auth.add_auth_handler(
//         scope = "crosschain.iccf_proof",
//         flags = []
//     );

// operation transfer_proxy(
//     transfer_tx: gtx_transaction,
//     origin_brid: byte_array,
//     id: integer,
//     target_brid: byte_array,
//     receiver_id: byte_array
// ) {
//     val owner = ft4.auth.authenticate();

//     // require proof
//     iccf.require_valid_proof(
//         transfer_tx,
//         require_anchored_proof = true,
//         verify_signers = false
//     );

//     var op = require(
//         transfer_tx
//         .body
//             .operations @? {
//             .name == "crosschain.transfer"
//         },
//         "No crosschain.transfer operation found"
//     );

//     val transfer_details = get_transfer_details(transfer_tx, op);
//     val prev_brid = transfer_tx.body.blockchain_rid;

//     val _token = require(token.token @? { transfer_details.args.origin_brid, transfer_details.args.id }, "token not found");
//     require(
//         not exists(completed_transfers @? { transfer_details.tx_rid }),
//         "Transaction <%s> transfer has already been applied on this chain."
//             .format(transfer_details.tx_rid)
//     );
//     require(owner.id == transfer_details.args.receiver_id, "Caller must be receiver of transfer");
//     require(
//         transfer_details
//             .args
//             .target_brid != chain_context
//             .blockchain_rid,
//         "Origin chain cannot be end target for proxy transfer"
//     );
//     require(transfer_details.args.origin_brid == chain_context.blockchain_rid, "Current chain is not origin chain");

//     create completed_transfers ( transfer_details.tx_rid );
//     // lock token
//     create locked ( _token, target_brid );
// }

// operation has_support_for_crosschain_transfer_crc1() {}
